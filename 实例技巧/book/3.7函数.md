#### js实现重载

重载的实质是在与根据参数类型和个数的不同定义多个同名函数

js因为定义同名函数会覆盖，并且有arguments集合接收参数，因此可以在内部判断arguments.length和每个参数的类型来实现'重载'。

```
function doAdd() {
    if(arguments.length == 1) {
    	alert(arguments[0] + 10);
    } else if (arguments.length == 2) {
    	alert(arguments[0] + arguments[1]);
    }
}
```

#### js引用类型与基本类型

基本类型是把实际的值存在变量中；引用类型是把实际的值存在内存中，变量中只存放对象的引用。引用类型的实际值存放在堆内存中，基本类型存放在栈中。

#### instanceof

定义的基本类型字面使用instanceof均为false，只有new出来的基本类型变量才是实例。

#### 作用域链

作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问。（直白点就是所有能访问到的变量的排序，有排序因此有了覆盖。）

每一个执行环境都有一个作用域链，作用域链的最前端（即排在最前面的）的变量对象时activation object是arguments，如果是全局环境则不存在arguments。下一个是包含（外层、上一层）环境，然后再上层，一直到最后一层是全局环境。标识符的解析就是从作用域链的前端到后端依次解析。

**以下是红宝书原话：**

*当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即arguments 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。*

#### with语句

with语句是能添加一个变量在作用域链的最前面（仅在with语句范围内有效）

```
function buildUrl() {
    var qs = "?debug=true";
    with(location){
    	var url = href + qs;
    }
    // 因为没有块级作用域
    return url;
}
```

#### JS垃圾回收

JS具有自动垃圾收集机制，执行环境自动回收管理内存。

回收机制有两种：标记清除与引用计数

标记清除：所有变量在分配内存时会被加上标记，然后会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量。

引用计数：当声明一个变量并将一个引用类型值赋值给该变量时，这个值的引用次数就是1。如果同一个值又被赋值给另一个变量，则该值的引用次数加1。相反如果这个变量取消了引用，则减1。如果引用次数变为0，则此变量无法访问，可以回收。

JS对象现阶段均为标记清除进行垃圾回收。

#### 自带垃圾回收，为什么还需要手动垃圾回收

IE中的一部分对象并不是JS对象，比如DOM、BOM，它们采用的是引用计数方式进行垃圾回收。

<font color=red>引用计数方式存在循环引用的隐患，导致计数永远不可能为0，只能手动取消引用才能归0。</font>

```
var element = document.getElementById("some_element");
var myObject = new Object();
myObject.element = element;//循环引用
element.someObject = myObject;//循环引用
//手动清除
myObject.element = null;
element.someObject = null;
```



## 第五章

##### 问题1：执行环境和上下文两个概念的区别

#### 大量传入可选参数时的函数体设计

<font color=red>必需值采用命名参数，可选参数使用对象字面量封装</font>

```
function Person(name,sex,info){
	this.name = name;
	this.sex = sex;
	if(typeof info.tel === "number"){
		this.tel = info.tel
	}
	if(typeof info.address === "string"){
		this.address = info.address;
	}
}
new Person("张三","男")
new Person("李四","男",{tel:13011112222,address:"北京"})
```

#### 数组方法

```
[1,2,3].shift(); // 删除第一项
[1,2,3].unshift(0);// 把 0 作为第一项加入到数组
[1,2,3].push(0); // 把 0 作为最后一项加入到数组
[1,2,3].pop(); // 删除最后一项
[1,2,3].sort((a,b)=>a-b); // 返回负数则位置交换
[1,2,3].reverse(); //数组翻转
[1,2,3].slice(2); //切割字符串，并返回切割副本，不修改原数组
[1,2,3].splice(); //最强大，第一个参数是删除的位置，第二个参数是删除的个数，第三个是新增的元素
[1,2,3].indexOf(1); //正向寻找 1 第一次出现的位置
[1,2,3].lastindexOf(1); //反向寻找 1 第一次出现的位置
[1,2,3].every(fn); // 每一项都返回true，整体才返回true

```

#### 

